---
title: JS按照值传递还是引用传递
date: 2018-03-07 10:39:10
categories:
- 前端
- JavaScript
tags:
- 参数传递
- 值传递
- 引用传递
---

## JS是按值传递还是按引用传递
　　按值传递(call by value)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。

　　按引用传递(call by reference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。

　　按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的BUG。
 
　　按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。

　　JS的基本类型，是按值传递的。

<!more-->

```
1 var a = 1;
2 function foo(x) {
3     x = 2;
4 }
5 foo(a);
6 console.log(a); // 仍为1, 未受x = 2赋值所影响
```
　　再来看看对象的传递：

```
1 var obj = {x : 1};
2 function foo(o) {
3     o.x = 3;
4 }
5 foo(obj);
6 console.log(obj.x); // 3, 被修改了!
```
```
1 var obj = {x : 1};
2 function foo(o) {
3     o = 100;
4 }
5 foo(obj);
6 console.log(obj.x); // 仍然是1, obj并未被修改为100.
```
　　可以看出，对象的值得传递并不是按引用传递。其实，按共享传递 call by sharing，准确的说，JS中的基本类型按值传递，对象类型按共享传递的(call by sharing，也叫按对象传递、按对象共享传递)。

　　该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。

　　总之，基本类型是按值传递，而对于对象来说传入的是对象指向的地址，也可以认为其是特殊的按值传递。如果在函数内对对象的属性进行操作，实际就是对其指向对象的属性进行操作。但是，如果对其整体进行操作（比如：o = 100或者o = []），其实际是新定于了对象，实参的引用地址为新的对象的引用地址，与原来的引用没有任何关系，所以不会对原来的对象造成改变。
